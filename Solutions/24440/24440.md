# [24440번](https://www.acmicpc.net/problem/24440)
[정답 코드](/Solutions/24440/24440.py)      
dp문제.   
괄호 문자열이 나타내는 값을 정하는 두번째 규칙인   
"괄호 문자열 a가 나타내는 값이 x라 할 때, (a)가 나타내는 값은 x + 1이다." 에 집착해서 계속 시간 초과로 틀렸던 문제.   

## 접근 1
우선 dp 문제일 것이라고 판단했고, 모든 경우에 대해서 배열에 채우는 방식을 생각했다.   
2는 무조건 () 이므로, 배열에 먼저 2를 저장하고, 3부터 시작해서 끝까지 채워나갔다.   
우선 n-1에 괄호를 하나 씌운 (dp[n-1])을 최소 문자열로 저장했다.   
그리고 2부터 루트 n까지 j값을 증가시키며 n을 j로 나눈 나머지가 0인 경우에 dp[j]+dp[n/j] 혹은 dp[n/j]+d[j]와 최소 문자열을 비교해서 최소 문자열에 저장하는 방식을 생각했다.   
당연하게도 시간 초과로 틀렸다.   

## 접근 2
모든 약수를 가지고 하는 경우에 시간 초과가 났으니, 무언가 규칙성이 있을 것이라 생각했다.   
가장 처음 생각 난 것은 소수였고, sqrt(10^6)인 1000 미만의 소수를 미리 구했다.  
그리고 접근 1의 방식에서 j값을 앞서 구한 소수만 사용하는 것으로 다시 해보았다.   
그럼에도 틀리게 되었고, 소수 구하는 부분에서 혹시 시간이 많이 잡아먹혀서 그럴 수도 있을 것이라 판단했다.   
그래서 미리 구해놓은 소수를 코드에 넣어서 해보았지만 역시나 틀렸다.   

## 접근 3
소수도 아니면, n 제곱근에서 가장 가까운 약수로 이루어져있다는 규칙이 있는건 아닐까 생각했다.   
그래서 n 제곱근에서 가장 가까운 약수를 찾고, 접근 1에서 처럼 최소 문자열과 비교해서 하는 방식을 사용해보았지만 틀렸다.   

## 접근 4
T가 20으로 작으니까, 상향식이 아니라 각 입력에 대해서 하향식으로 접근하면 빠를지도 모른다는 생각을 했다.   
하지만, 접근 1에서 한 것 처럼 최소 문자열을 (dp[n-1])로 저장했기 때문에 결과적으로는 기존에 틀렸던 방식과 다른게 없었다.   

## 접근 5
(a)인 경우를 바로 이전값에서만 찾지 않고, j로 나눈 나머지 만큼 추가해 주는 방식을 생각했다.   
이렇게 하면 하향식으로 접근했을 때, 접근 3에서처럼 모든 경우를 찾지 않아도 될 것이고, 더 빠른 속도로 답을 구할 수 있을 것이라 생각했다.   
그래서 제출 했는데, 내가 설정한 반복문에서는 3이 제대로 구해지지 않아서, 값들이 모두 이상한 값으로 정해지는 문제가 있었다.   
그래서 3에 해당하는 (())도 dp 배열에 미리 저장해 놓았고, 맞았다.   